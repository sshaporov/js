1. var, let, const (типы переменных)
let и const были введены в ES6 и имеют блочную область видимости, в то время как var имеет функциональную область видимости.
Let:
    - Область видимости переменной let – блок {...}
    - Переменная let видна только после объявления
    - При использовании в цикле, для каждой итерации создаётся своя переменная
Const:
    - задаёт константу, то есть переменную, которую нельзя менять
    - У переменной const должна быть явная инициализация значением. 
    - eсли вам нужна константа со значением undefined, то придётся явно её инициализировать этим значением.
    - если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё 
Отличия let и const от var:
    - let и const могут быть объявлены только один раз в одной и той же области видимости, при повторном объявлении будет возникать 
       ошибка SyntaxError: Identifier 'name' has already been declared.
    - если обратиться к переменным let и const до их объявления, то возникнет ошибка ReferenceError, в отличие от переменной var, 
      значение которой в таком случае отобразится как undefined. Такая ошибка ReferenceError из-за попытки получить или установить 
      значение let или const переменной до её объявления называется ошибкой “Временной мертвой зоны” (Temporal Dead Zone (TDZ) error).
    - объявленные в глобальной области видимости функции и var переменные помещаются в свойства глобального объекта window

2. Hosting (всплытие)
Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, 
как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. 
Hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не 
происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на 
том месте, где вы их объявили (см задачи по хостингу в папке ./hosting)

3. Мертвая зона
Это когда мы обращаемся к переменной let или const в коде до ее реализации

4. Prototype
Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга
каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. 
Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так дале
(см теорию в папке или конспект)

5. Null 
Значение null представляет отсутствие какого-либо объектного значения. В JavaScript, null является примитивом, и в контексте 
логических операций, рассматривается как ложное (falsy).
Значение null записывается литералом null. Оно является самостоятельным, а не свойством глобального объекта (как undefined). 
Отличия между null и undefined: 
    - null является определённым значением отсутствия объекта, тогда как undefined обозначает неопределённость
    - При проверке на null или undefined, помните о различии между операторами равенства (==) и идентичности (===): с первым, 
    выполняется преобразование типов. 
        typeof null        // object (не "null" из соображений обратной совместимости)
        typeof undefined   // undefined
        null === undefined // false
        null  == undefined // true

6. Undefined
Значение глобального свойства undefined представляет значение undefined. Это одно из примитивных значений JavaScript.
Undefined является свойством глобального объекта, то есть, это переменная в глобальной области видимости. Начальным значением 
undefined является примитивное значение undefined.
Переменная, не имеющая присвоенного значения, обладает типом undefined. Также undefined возвращают метод или инструкция, 
если переменная, участвующая в вычислениях, не имеет присвоенного значения. Функция возвращает undefined, если она не возвращает 
какого-либо значения.
Поскольку undefined не является зарезервированным словом, он может использоваться в качестве идентификатора (имени переменной) 
в любой области видимости, за исключением глобальной.
Использование в логических выражениях:
    - x - определена:
        var x;
        if (x === undefined)
    - x - определена:
        var x;
        if (typeof x === 'undefined')
    - x - не определена
        if (typeof x === 'undefined') {} // вычислится в true без ошибок

7. Falsy
Это значение, которое считается ложным, когда встречается в контексте Boolean .
JavaScript приводит любое значение к логическому, где требуется логический контекст - выражения и циклы.
В JavaScript есть только 7 ложных значений. Это означает, что когда JavaScript ожидает логическое значение и ему присваивается одно 
из значений ниже, он всегда будет оцениваться как «ложное»:
false	    Ключевое слово false
0, -0	    Число zero
0n	        BigInt, при использовании в качестве логического значения, следует тому же правилу, что и число. 0n - это ложь.
"", '', ``	Это пустая строка(длина строки ноль). Строки в JavaScript могут быть определены с помощью двойных кавычек (") или 
            одинарных кавычек ('), а также Template literals (`)
null	    null - отсутствие какого-либо значения
undefined	undefined - примитивное значение
NaN     	NaN - не число

8. Truthy
В JavaScript, истинное значение - это значение, которое считается true, когда встречается в контексте Boolean. Все значения истинные, 
если они не определены как falsy (кроме false, 0, -0, 0n, "", null, undefined, и NaN).
JavaScript использует приведение типов в Boolean контекстах.
Примеры истинных значений в JavaScript (которые будут приведены к true в булевых выражениях, и таким образом выполниться блок if):
if (true)
if ({})
if ([])
if (42)
if ("0")
if (new Date())
if (-42)
if (12n)
if (3.14)
if (-3.14)
if (Infinity)
if (-Infinity)

