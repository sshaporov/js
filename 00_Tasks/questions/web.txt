1. HTTP протокол
Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После этого браузер 
изучает этот документ и запрашивает дополнительные файлы, необходимые для отображения содержания веб-страницы (исполняемые скрипты, 
информацию о макете страницы - CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые 
непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы 
для отображения их пользователю в виде единого документа — веб-страницы. Скрипты, выполняемые самим браузером, могут получать по 
сети дополнительные ресурсы на последующих этапах обработки веб-страницы, и браузер соответствующим образом обновляет отображение 
этой страницы для пользователя.

Запросы содержат следующие элементы:
- HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет 
  выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие 
  операция могут быть необходимы в других случаях.
- Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без протокола (http://), домена 
  (здесь developer.mozilla.org), или TCP порта (здесь 80).
- Версию HTTP-протокола.
- Заголовки (опционально), предоставляющие дополнительную информацию для сервера.
- Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.

Ответы содержат следующие элементы:
- Версию HTTP-протокола.
- HTTP код состояния, сообщающий об успешности запроса или причине неудачи.
- Сообщение состояния — краткое описание кода состояния.
- HTTP заголовки, подобно заголовкам в запросах.
- Опционально: тело, содержащее пересылаемый ресурс.


2. Протоколы передачи данные в сети интернет
http://ecocyb.narod.ru/471-472/inrs5_2.htm


3. Что такое RESTful:
Чтобы распределенная система считалась сконструированной по REST архитектуре (Restful), необходимо, чтобы она удовлетворяла 
следующим критериям:
- Client-Server. Система должна быть разделена на клиентов и на серверов. Разделение интерфейсов означает, что, например, клиенты 
  не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не 
  связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть 
  заменяемы и разрабатываться независимо, пока интерфейс не изменяется.
- Stateless. Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация для 
  обработки запроса и если необходимо, идентификации клиента.
- Cache․ Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами 
  устаревших или некорректных данных в ответ на дальнейшие запросы.
- Uniform Interface. Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, 
  которая позволяет каждой части развиваться самостоятельно.


4. Идемпотентность
С точки зрения RESTful-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов 
неоднократно при одном и том же результате на сервере. Другими словами, создание большого количества идентичных запросов имеет 
такой же эффект, как и один запрос. Заметьте, что в то время, как идемпотентные операции производят один и тот же результат на 
сервере, ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).
Методы PUT и DELETE по определению идемпотентны. Тем не менее, есть один нюанс с методом DELETE. Проблема в том, что успешный 
DELETE-запрос возвращает статус 200 (OK) или 204 (No Content), но для последующих запросов будет все время возвращать 
404 (Not Found), Состояние на сервере после каждого вызова DELETE то же самое, но ответы разные.
Методы GET, HEAD, OPTIONS и TRACE определены как безопасные. Это означает, что они предназначены только для получения информации 
и не должны изменять состояние сервера. Они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: 
логирование, кеширование, показ баннерной рекламы или увеличение веб-счетчика.
По определению, безопасные операции идемпотентны, так как они приводят к одному и тому же результату на сервере. Безопасные методы 
реализованы как операции только для чтения. Однако безопасность не означает, что сервер должен возвращать тот же самый результат 
каждый раз.


5. REST
Это архитектурный стиль взаимодействия компонентов распределенной системы в компьютерной сети. Проще говоря, REST определяет стиль 
взаимодействия (обмена данными) между разными компонентами системы, каждая из которых может физически располагаться в разных местах.
Данный архитектурный стиль представляет собой согласованный набор ограничений, учитываемых при проектировании распределенной системы. 
Эти ограничения иногда называют принципами REST. Их немного, всего 6 штук.
    1. Приведение архитектуры к модели клиент-сервер
    2. Отсутствие состояния
       В период между запросами серверу не нужно хранить информацию о состоянии клиента и наоборот. Все запросы от клиента должны 
       быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса
    3. Кэширование
    4. Единообразие интерфейса
    5. Слои
       Иногда клиент может общаться напрямую с сервером, а иногда — просто с промежуточным узлом. Применение промежуточных серверов 
       способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Клиент запросит картинку у 
       промежуточного узла, промежуточный узел запросит картинку у сервера, который наименее загружен в данный момент, и вернет к
       артинку клиенту. Если здесь на каждом уровне иерархии правильно применить кэширование, то можно добиться хорошей 
       масштабируемости системы.
    6. Код по требованию (необязательное ограничение)
       Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в виде 
       апплетов или сценариев. 
Преимущества, которые дает REST:
- надёжность (не нужно сохранять информацию о состоянии клиента, которая может быть утеряна);
- производительность (за счёт использования кэша);
- масштабируемость;
- прозрачность системы взаимодействия;
- простота интерфейсов;
- портативность компонентов;
- лёгкость внесения изменений;
- способность эволюционировать, приспосабливаясь к новым требованиям.


6. Типы данных в JSON
строка номер объект массив True ложь NULL


7. Кеширование
Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. 
Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из 
кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается 
производительность — кеш ближе к клиенту и ресурс передаётся быстрее. Кеширование является основным источником повышения 
производительности веб-сайтов.
Управление кешированием
- Полное отсутствие кеширования Cache-Control: no-store
- Кешировать, но проверять актуальность
  Перед тем, как выдать копию, кеш запрашивает исходный сервер на предмет актуальности ресурса.
  Cache-Control: no-cache
- Приватные (private) и общие (public) кеши. Директива "public" указывает, что ответ можно сохранять в любом кеше
  Cache-Control: private
  Cache-Control: public
- Срок действия (Expiration)
  Самой важной здесь является директива "max-age=<seconds>" — максимальное время, в течение которого ресурс считается "свежим". 
  В отличие от директивы Expires, она привязана к моменту запроса.
- Проверка актуальности
  При использовании директивы "must-revalidate" кеш обязан проверять статус ресурсов с истёкшим сроком действия. Те копии, что 
  утратили актуальность, использоваться не должны. 
Валидация кеша
Валидация кеша запускается при нажатии пользователем кнопки перезагрузки. Кроме того, она может выполняться в ходе обычного 
просмотра страниц, если кешированный ответ включает заголовок "Cache-control: must-revalidate". Другим фактором являются настройки 
кеширования браузера — можно потребовать принудительной валидации при каждой загрузке документа.
При истечении срока годности документа он либо проходит валидацию, либо повторно доставляется с сервера. Валидация может выполняться 
только если на сервере реализован сильный валидатор или слабый валидатор.

