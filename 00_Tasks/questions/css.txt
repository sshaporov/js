1. Специфичность селекторов
Не важно в какой последовательности идет перечисление класса, они будут применяться согласно правилам css - последовательно
построчно.
Задача: какого цвета будет текст Раз / Два
    .green {
        color: green;
    } 
    .blue {
        color: blue;
    } 
    <div class="green blue">Раз</div>
    <div class="blue green">Два</div>

Специфичность CSS важна только тогда, когда несколько селекторов влияют на один и тот же элемент. Браузеру нужен способ 
выяснить, какой стиль применять к соответствующему элементу, когда существуют противоречивые значения свойств.
    - Когда два или более совпадающих селектора имеют одно и то же значение (вес) специфичности, браузер выбирает «самый 
    последний» совпадающий селектор, который появляется ближе к нижней части списка совпадающих селекторов. Следующий пункт 
    объясняет, что такое «список подходящих селекторов».
    - Браузер формирует «список подходящих селекторов», комбинируя все стили на веб-странице и отфильтровывая те, которые не 
    ветствуют элементу «currently-being-styled». Первые селекторы в таблице стилей находятся вверху списка, а последние селекторы — 
    внизу.
    - Свойство style для элемента имеет большее значение специфичности, чем селекторы в таблицах стилей, за исключением случаев, 
    когда есть !important в селекторе таблиц стилей.
    - Использование !important (что в некоторых случаях считается плохой практикой) изменяет специфичность селектора. Когда два 
    селектора имеют одинаковую специфичность, выигрывает селектор с !important. И когда они оба имеют !important, «самый последний» 
    селектор выигрывает.

Специфичность селектора может быть представлена в виде трехзначной строки, разделенной дефисом (или чем угодно): «2–4–1». Первая 
цифра — это количество присутствующих селекторов ID, вторая — это количество селекторов классов, селекторов атрибутов и 
псевдоклассов, а третья — количество имеющихся селекторов типов и псевдоэлементов.
    #red.blue // 1-1-0
    #green // 1-0-0
    div.yellow#red // 1-1-1
    .red.blue.yellow // 0-3-0
Скажем, у вас есть 1-1-1 и 0-3-0, как в двух последних примерах, и вам нужно определить, какой из них имеет большую специфичность. 
Сначала вы сравниваете последние значения 1 и 0, и в этом случае выигрывает 1. Это означает, что на данный момент div.yellow#red 
имеет большее значение специфичности… но мы еще не закончили сравнение значений.
Далее сравниваем значения 1 и 3, 3 выигрывает. На данный момент .red.blue.yellow имеет большее значение специфичности.
Наконец, сравниваем первые значения, 1 и 0, и выигрывает 1, так что div.yellow#red обладает большей специфичностью, 
чем .red.blue.yellow.

2. Селекторы CSS
Селектор в CSS — это указатель на элемент или группу элементов, к которым будут применяется правила стилей. Существуют следующие виды селекторов:
    1. Селекторы по тэгам: h1
    2. Селектор по id: #main
    3. Селекторы по классам: .hidden
    4. Селектор по нескольким классам: .hidden.closed
    5. Контекстные селекторы разделяются пробелом . Используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент: p strong или .header .menu a
    6. Соседние селекторы. Выделяет последующий элемент. Записываются с помощью знака +. Читается как: применить свойства к селектор2 который должен быть сразу после селектор1.
        <li class="green"></li>
        <li class="selected"></li>
        В примере .green + .selected применит стили ко второму элементу, т.к. перед ним есть элемент с классом .green. Селектор.green + li тоже применит стили ко второму элементу, а селектор .selected + .green не сработает.
    7. Родственные селекторы. Выделяет последующие элементы. Похожи на предыдущий, но с тем различием, что выбираются все следующие элементы, а не только первый элемент.
    8. Дочерние селекторы. Записываются с помощью знака > и распространяются только на элементы первого уровня вложенности. На элементы вложенные в другие элементы не распространяются.
    9. Селекторы атрибутов
        input[type="text"]
        input[checked]
        div[data-type="image"]
        a[href*=".com"]
        a[href^="http"]
        a[href$=".jpg"]
        a[data-info~="bar"]
    10. Глобальный селектор. Селектор * выберет все элементы. Его также можно использовать для выделения дочерних элементов:
        * { margin: 0; padding: 0; }
        .content * { outline: none; }
    11. Псевдоклассы
        a:link
        a:visited
        a:active
        a:hover
        input[type=radio]:checked
        .clearfix:after {}
        div:not(#container)
        p::first-line
        p::first-letter
        Псевдокласс отрицания :not бывает очень полезным. Например, когда необходимо выбрать все div, за исключением того, который имеет id container.


3. Основные концепции CSS
Группировка - группировка нескольких стилей
Комбинация селекторов - a.header[href*=".ru"]
Наследование - передача свойств от предка к потомку
    а) Автоматическое наследование:color, font, letter-spacing, line-high, list-style, text-align,text-indent, text-transform, 
    visability, word-spacing, whit-spacing
    б) Принудительное наследование .section h1 { margin-top: inherit }
Каскадирование - к одному и тому же элементу может быть несколько стилей (стили накладываются друг на друга). Перебить 
каскадирование !important


4. Единицы измерения: px, em, rem
px – абсолютные пиксели. Используется для максимально конкретного и точного задания размеров.
em – задаёт размер относительно шрифта родителя, можно относительно конкретных символов: "x"(ex) и "0"(ch), используется там, где 
    нужно упростить масштабирование компоненты.
rem – задаёт размер относительно шрифта <html>, используется для удобства глобального масштабирования: элементы которые планируется 
    масштабировать, задаются в rem, а JS меняет шрифт у <html>.
% – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него 
    никуда, но надо знать, относительно чего он считает проценты.
        В применяемых свойствах процент берется от размера шрифта родителя
        margin-left - от ширины родительского блока, а вовсе не от его margin-left
        line-height - берётся от текущего размера шрифта, а вовсе не от line-height родителя
        width/height - от ширины/высоты родителя, но при position:fixed, процент берётся от ширины/высоты окна (а не родителя и не документа). Но есть и доп условия
vw, vh, vmin, vmax – относительно размера экрана.


5. Схлопывание отступов (margin) https://habr.com/ru/post/465839/
Два margin схлопываются, пространство между элементами становится равным большему из этих двух отступов.
margin схлопываются только в направлении блока, например между параграфами.
Схлопывание внешних отступов происходит в трёх случаях:
    - Смежные соседние элементы
        Если у вас есть два элемента, отображающихся один за другим в нормальном потоке, нижний margin первого элемента будет 
        схлопываться с верхним margin последующего элемента.
    - Пустые блоки
        Если блок пустой, его верхний и нижний margin могут схлопываться друг с другом.Если второй элемент не виден, так как пустой 
        имеет верхний и нижний margin по 50px, однако, пространство между первым и третьим элементами не 100 пикселей, а 50. Это 
        является следствием схлопывания двух margin.
    - Родитель и первый/последний дочерний элемент
        Все три дочерних элемента имеют margin по 50 пикселей. Тем не менее, первый и последний элементы примыкают к границам 
        элемента-обертки; нет отступа в 50 пикселей между элементом и оберткой.
        Это происходит потому, что margin дочернего элемента схлопывается с любым margin родителя таким образом, что заканчивается 
        за пределами родителя.
Не происходит схлопывание:
    - Отступы плавающих и абсолютно позиционированных элементов никогда не схлопываются.
    - Схлопывание margin не происходит в ситуации, когда что-то находится между ними^ если блоку задана рамка (border) или внутренние отступы (padding)
    - Создание «Блочного контекста форматирования»
        Новый «Блочный контекст форматирования» (BFC) предотвратит выпадение margin за пределы родительского элемента. Если мы снова 
        посмотрим на пример с первым и последним дочерними элементами, margin которых выпадают за пределы элемента-обёртки, и зададим обёртке display: flow-root, создав таким образом BFC, margin дочерних элементов останутся внутри.


6. Сверстать на основе ul и li горизонтальное меню (flex)
    ul {
        list-style: none
        display: flex
        flex-direction: row
        width: fit-content ???
        padding: 0
    }

    li {
        padding: 5px 20px
    }


7. Сверстать на основе ul и li горизонтальное меню (inline-block)
    ul {
        list-style: none
        padding: 0
    }
    li {
        padding: 5px 20px
        display: inline-block
    }
Для того чтобы избавиться от расстояния между инлайн блоков, которая появляется изза переноса на след строку элемента <li>, нужно:
- добавить для ul font-size: 0
- добавить нужный размер шрифта для li font-size: 12px


8. Соединение двух массивов
- concat()
    возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, 
    переданными в качестве аргументов.
        const array1 = ['a', 'b', 'c'];
        const array2 = ['d', 'e', 'f'];
        const array3 = array1.concat(array2);
- spred
    const array3 = [...array1, ...array2];


9. По клику на элемент списка отобразить его содержимое в див
    const fruits = ['banana', 'apple', 'lime', 'lemon']
    let list = document.querySelector("ul")
    let result = document.querySelector("#content")
    
    for(let i = 0; i < fruits.length; i++) {
        let element = document.createElement('li');
        element.innerHTML = fruits[i];
        element.onclick = function() {
        result.innerHTML = fruits[i];
    }
    list.appendChild(element);
    }
.. можно повесить клик на сам список ul и спомощью this.target (с праверкой на li) определять на какой li мы нажали (в случае если мы вставили все лишки как html)