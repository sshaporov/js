http://jsflow.org/docs/lex-env/

1. УСТРОЙСТВО JavaScript-движков
Программы, которые переводят и выполняют код, написанный на JavaScript, называются JavaScript-движками.
Вообще, в программировании для этих целей существует два основных подхода - это использовать интерпретатор или компилятор.

- Интерпретатор - это программа, реализующая построчный анализ, обработку и выполнение исходного кода программы.
  Простой интерпретатор анализирует и тут же выполняет программу построчно (покомандно), по мере поступления её исходного кода. 
  Достоинством такого подхода является мгновенная реакция на команды. Недостаток в том, что интерпретатору приходится проделывать 
  одну и ту же работу, когда вы используете одинаковый код несколько раз. Например, если вы находитесь в цикле, 
  интерпретатор будет анализировать одни и те же строки снова и снова. 
  Интерпретатор обнаруживает ошибки в коде только при попытке выполнения строки с ошибкой. И никак не сможет сообщить об ошибке 
  в коде с самого начала.

- Компилятор не выполняет программу построчно, сначала, он последовательно анализирует и разбирает код программы, производит 
  необходимую оптимизацию и только после этого генерирует машинный код, который впоследствии начнет выполняться.
  Поэтому, при компиляции требуется больше времени для запуска, так как в начале должны пройти все её этапы.

- Динамическая компиляция.
  При первом выполнении JavaScript-кода он полностью прогоняется через компилятор, который сразу, без каких-либо дополнительных 
  оптимизаций, преобразовывает его в машинный код. Это позволяет очень быстро приступить к его выполнению или сообщить об ошибках 
  в нашем коде на начальной стадии. После того, как код какое-то время поработает, профилировщик (профилировщик - сообщает 
  системе о том, в каких методах программа тратит больше всего времени, чтобы в дальнейшем их можно было оптимизировать) 
  соберёт достаточно данных для того, чтобы система могла понять, какие методы нужно оптимизировать. Например, когда одна и та 
  же функция выполняется несколько раз, компилятор берет её отдельно в работу. Где она оптимизируется и сохраняется в новом виде. 
  При следующем обращении к этой функции вызовется уже её оптимизированная версия, тем самым ускорив процесс её выполнения.



2. ОБЛАСТЬ ВИДИМОСТИ
Область видимости переменных или просто “Область видимости” (англ. variable scope или просто scope) — это такая область программы, 
в пределах которой установлена связь между некоторой переменной и её идентификатором (именем), по которому можно получить значение 
этой переменной. За пределами области видимости тот же самый идентификатор может быть связан с другой переменной, либо быть 
свободным (вообще не связанным ни с какой из переменных).
- Глобальная область видимости - это та, у которой нет внешней области видимости (внешнего окружения). Она является отправной 
  точкой нашей программы и самой внешней областью видимости для всех других, которые в неё вложены.
- Переменные называются глобальными, если они доступны из любой точки программы. То есть те, которые объявлены в глобальной, 
  самой внешней области видимости. 
- Переменные, которые объявлены внутри функции и недоступны снаружи, называются локальными переменными. Область видимости, 
  ограниченная функцией или блоком, это локальная область видимости.
- Если в текущей области переменная не определена, то значение возьмется из ближайшего окружения (родительской области видимости), 
  в котором определена необходимая переменная.
- “Затенение переменных”, когда текущая переменная скрывает значение переменной объявленной в родительской области видимости.
- Также область видимости может быть ограничена блоком инструкций.



3. БЛОКИ КАК ОБЛАСТИ ВИДИМОСТИ. ПЕРЕМЕННЫЕ let И const
Концепция областей видимости позволяет разграничить доступ определенных частей программы к переменным, методам или другим 
инструкциям так, чтобы этим частям был доступен только необходимый минимум ресурсов для выполнения их задачи.
До выхода стандарта ES6 функции были наименьшей единицей, ограничивающей области видимости.
Для этих целей раньше обычно использовались немедленно вызываемые функциональные выражения — IIFE (Immediately Invoked 
Function Expression) которые представляют собой функции, выполняющиеся сразу же после того, как они были определены.

С выходом ES6 блок инструкций {...} теперь тоже может ограничивать область видимости. Только в отличие от функций, ограничивающих 
область видимости переменных, объявленных любым способом (через var, const и let), блок инструкций ограничивает область видимости 
только для переменных, которые объявлены через const и let. Если в блоке объявить переменную var, то она будет доступна вне 
блока и будет ограничиваться функцией, в которой этот блок находится.

Единственными примерами блочной области видимости еще со стандарта ES3 были:
- инструкция with
- блок catch в конструкции для обработки ошибок try...catch

Let:
- Область видимости переменной let – блок {...}
- Переменная let видна только после объявления
- При использовании в цикле, для каждой итерации создаётся своя переменная

Const:
- задаёт константу, то есть переменную, которую нельзя менять
- У переменной const должна быть явная инициализация значением. 
  Если вам нужна константа со значением undefined, то придётся явно её инициализировать этим значением.
- если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё 

Обратите внимание, что переменные let и const, в отличие от переменных var, могут быть объявлены только один раз в одной и 
той же области видимости. При повторном объявлении будет возникать ошибка SyntaxError: Identifier 'name' has already been declared.

Функции ограниченные блочными областями видимости.
В режиме use strict, функции, объявленные внутри блока {...} тоже имеют область видимости, ограниченную этим блоком. В данном 
случае вызов функции вызовет ошибку ReferenceError так как вне блока, где она была объявлена, эта функция не определена. 
Без строгого режима этот код будет работать без ошибок, так как объявление функций уже не будет ограничиваться блоками инструкций.

         "use strict";
         let age = prompt("Сколько Вам лет?", 18);
         let welcome;

         if (age < 18) {
         welcome = function() {
            console.log("Привет!");
         };
         } else {
            welcome = function() {
            console.log("Здравствуйте!");
            };
         }
         welcome(); // будет работать, так как объявленная переменная welcome видна во всём коде

Блочную область видимости не следует использовать как полную замену функциональной области видимости var. Стоит использовать 
обе области видимости: функциональную и блочную, в соответствующих местах, чтобы создавать лучший, более читаемый/обслуживаемый код.



4. ЛЕКСИЧЕСКИЕ ОБЛАСТИ ВИДИМОСТИ И ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ
Исходный код программы последовательно анализируется и разбирается компилятором. Первым традиционным этапом работы стандартного 
компилятора является лексический анализ исходного кода.На этом этапе каждая строка кода посимвольно анализируется и разбивается 
на значимые для языка части. Эти имеющие смысл для языка части называются лексемами.

Лексическое окружение — это определенная структура, которая используется для определения связи Идентификаторов (имен) с конкретными 
переменными и функциями на основе вложенности (цепочки) лексических областей видимости.

Переменные начинают своё существование тогда, когда выполнение программы достигает их области видимости. И тогда этим переменным 
необходимо место для хранения, чтобы впоследствии к ним можно было обратиться даже из вложенных областей видимости. В спецификации 
JavaScript, структура данных, которая обеспечивает такое пространство для хранения переменных в памяти, а также предоставляет 
механизм их поиска и возможность получить к ним доступа из внутренних областей, называется лексическим окружением.

Cуть лексических областей видимости в том, что даже на этапе выполнения программы, они сохраняют связь со своими внешними/
родительскими областями, которые были определены на этапе лексического разбора (то есть сформированы исходя из того, где 
переменные, яфункции и инструкций изначально были написаны в коде).За счет сохранения такой связи формируется целая цепочка 
областей видимости, каждая из которых знает свою родительскую область видимости.

Каждая функция, которая является в свою очередь отдельной областью видимости, на этапе инициализации, запоминает свою родительскую 
область видимости, где она содержится. Это происходит за счет того, что у каждой функции есть внутреннее свойство [[Environment]] 
оторое сохраняет в себе ссылку на внешнюю область видимости (это свойство недоступно нам из самой программы и используется 
JavaScript-движком).

Каждый раз когда обрабатывается такой код, например вызывается функция или обрабатывается блок инструкций, то для этой новой 
области видимости создаётся своё Лексическое окружение. Для этого окружения формируется:
1. Запись Окружения environment record, которая содержит в себе связи идентификаторов с переменными, которые созданы в области 
   видимости этого Лексического окружения. Также она содержит и другую необходимую информацию, например значение ключевого слова 
   this, о котором будет рассказано в другой части.
2. Ссылка outer, которая указывает на внешнее/родительское окружение для этой области видимости. Именно в это поле попадает 
   значение внутреннего свойства [[Environment]], которое хранит в себе ссылку на родительскую область видимости. И поэтому 
   всегда существует цепочка Лексических окружений. Она начинается с текущего (выполняющегося в данный момент) Лексического 
   окружения, продолжается внешними окружениями, и заканчивается глобальным Лексическим окружением, у которого поле outer равно null.