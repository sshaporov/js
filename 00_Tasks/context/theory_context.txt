http://jsflow.org/docs/exec-context-fundamentals/

https://www.youtube.com/watch?v=raXBB5mIh74&ab_channel=IT-KAMASUTRA
https://www.youtube.com/watch?v=Yudv3ENewkI&ab_channel=IT-KAMASUTRA
https://www.youtube.com/watch?v=KzaRjHrNb7w&ab_channel=IT-KAMASUTRA

1. КОНТЕКСТ ВЫПОЛНЕНИЯ. ОСНОВЫ
Лексическое окружение позволяет сформировать доступный нам набор переменных и функций, учитывая вложенность кода. Но по ходу 
выполнения программы этот набор данных изменяется, более того у каждой вызванной функции своё собственное лексическое окружение. 
Каким образом можно отследить происходящие в лексическом окружении изменения, а также определить какое лексическое окружение 
является текущим, соответствующим данному этапу выполнения кода? Для этих целей используется контекст выполнения.

Контекст выполнения (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его 
помощью определяется доступное окружение на текущем этапе выполнения программы. А также контекст выполнения содержит в себе 
дополнительные параметры, которые формируются самостоятельно JavaScript-движком при обработке вашего кода.

Контекст выполнения тоже является абстрактным механизмом спецификации, как и лексическое окружение, к которому невозможно 
напрямую обратиться или изменить из программы. По сути он представляет собой некую обертку для выполняемого кода, содержащую 
определенные вспомогательные компоненты для отслеживания состояния программы, к некоторым из которых, мы можем обратиться из 
нашего кода. Одним из таких динамически устанавливаемых параметров, к которому можно напрямую обратиться из кода и получить 
доступ к определенному набору данных в рамках текущего контекста выполнения, является ключевое слово this.

Первым контекстом выполнения, который создаётся при запуске JavaScript скрипта является глобальный контекст выполнения 
(Global Execution Context). В рамках этого контекста будет обрабатываться весь глобальный код программы. Соответственно текущим 
Лексическим окружением, связанным с глобальным контекстом выполнения, является глобальное глобальное окружение Global Environment.

- В JavaScript есть такая особенность, что объявленные в глобальной области видимости функции и var переменные помещаются в свойства 
  глобального объекта window
- если в коде присвоить значение какой-либо необъявленной ранее переменной и, если этот код выполняется не в строгом режиме 
  “use strict”, то JavaScript не только не отобразит ошибку, о несуществующей переменной, но и создаст её для нас в глобальном объекте

Когда в JavaScript программе кроме глобального кода есть еще вызов функций. То при каждом новом вызове функции создаётся свой 
контекст выполнения, при этом текущий контекст выполнения (тот, откуда была вызвана функция) приостанавливается.
Чтобы хранить и отслеживать контексты выполнения они формируются в стек контекстов выполнения (call stack) — список контекстов, 
организованных по принципу «последним пришёл — первым вышел». Выполняемый контекст всегда является верхним элементом этого стека. 
После того, как необходимый код выполнится, связанный с ним контекст выполнения удалится, управление вернется в контекст, 
который находился элементом ниже, и теперь он будет верхним элементом — текущим контекстом выполнения.



2. ЭТАПЫ СОЗДАНИЯ И ВЫПОЛНЕНИЯ КОНТЕКСТА
I. Этап создания - это этап, в котором JavaScript-движок вызвал функцию, но само ее выполнение еще не началось. На этапе создания 
контекста JavaScript-движок находится на фазе компиляции, то есть он просматривает код этой функции для последующей его компиляции.

(на этапе создания контекста, до выполнения функции, JavaScript-движок исследует код и формирует контекст, который содержит в 
себе указатель на текущее Лексическое окружение, связанное с выполняемым кодом)

Запись Окружения меняется в течение выполнения кода. Она создаётся и начинает формироваться на этапе создания контекста. В неё 
помещаются все объявленные в коде переменные и функции, тем самым для них резервируется место в памяти еще до выполнения первой 
строчки кода.
Важно заметить, что на этапе создания контекста, переменные и функциональные выражения, такие как:
    var x = 10;
    var func = function(params) {
    // тело функции
    };
не инициализируется указанным значениями, а попадают в запись окружения со значением undefined.
Это происходит потому, что сам код еще не выполняется, и никаких операций присваиваний еще не произошло. JavaScript-движок лишь 
просканировал код и сформировал запись окружения из имен объявленных переменных и функций. Исключением являются обычные объявления 
функций, такие как:
    function name(params) {
    // инструкции...
    }
Они целиком, вместе с телом функции и встроенными свойствами, помещаются в запись окружения.

Именно из-за формирования записи окружения и выделения памяти под переменные до выполнения кода к ним можно обращаться до их 
объявления в программе. Такое поведения называется “всплытие” или hoisting.

Для переменных let и const есть некоторые отличия от var переменных в механизме всплытия. Например, если обратиться к переменным 
let и const до их объявления, то возникнет ошибка ReferenceError, в отличие от переменной var, значение которой в таком случае 
отобразится как undefined. Такая ошибка ReferenceError из-за попытки получить или установить значение let или const переменной 
до её объявления называется ошибкой “Временной мертвой зоны” (Temporal Dead Zone (TDZ) error). Механизм временной мертвой зоны 
базируется именно на контексте выполнения. В следующем примере видно, что временная мертвая зона заканчивается именно тогда, 
когда само выполнение кода доберется до объявления переменной.

II. После этапа создания контекста начинается второй этап - выполнение кода. Написанный код, построчно интерпретируется и 
выполняется JavaScript-движком.
Рассмотрим пример выполнения кода:
    console.log("Первое обращение: " + text);
    var text = "Всем привет!";
    console.log("Второе обращение: " + text);

Результат выполнения кода:
    > "Первое обращение: undefined"
    > "Второе обращение: Всем привет!"

В данном случае, на этапе выполнения, первое обращение не вызовет ошибки и выведет undefined именно из-за пройденного этапа 
создания контекста выполнения, на котором код был целиком исследован/обработан JavaScript-движком, в результате чего объявленная 
в нём переменная text добавилась в запись окружения и под неё выделилось место в памяти. Иными словами произошло “всплытие 
этой переменной”. Но само значение этой переменной еще не было присвоено, это произойдет только после выполнения строки с 
объявлением переменной, где ей присваивается определенное значение — “Всем привет!”. Поэтому при первом обращении будет выведено 
undefined, а при втором выведется уже заданное при объявлении значение переменной.



3.ВЫЗОВ ФУНКЦИЙ И СТЕК ВЫПОЛНЕНИЯ ФУНКЦИЙ
http://jsflow.org/docs/exec-stack/



4. КОНТЕКСТ ВЫПОЛНЕНИЯ И БЛОЧНАЯ ОБЛАСТЬ ВИДИМОСТИ
Контекст Выполнения включает в себя указатель на текущее Лексическое окружение, связанное с выполняемым кодом. Но с появлением 
в ES6 новых возможностей, таких как блочная области видимости и переменных let и const возникла необходимость, чтобы в рамках 
каждого Контекста Выполнения были два Лексических Окружения вместо одного. Это позволило реализовывать новые возможности стандарта, 
но при этом разграничить их от уже существующих ранее.
Таким образом, чтобы реализовать новый функционал, но при этом сохранить предыдущую логику работы и механизм всплытия var 
переменных и объявлений функций, к ранее единственному Лексическому Окружению LexicalEnvironment, было добавлено дополнительное 
Лексическое Окружение VariableEnvironment.
На этапе создания нового контекста выполнения они полностью указывают на одно и то же Лексическое Окружение и полностью одинаковы, 
поэтому в теме “Создание контекста выполнения” использовался общий термин - Лексическое Окружение.
Но вместо одной общей Записи Окружения environmentRecord существуют две записи, одна для VariableEnvironment, другая для 
LexicalEnvironment, которые полностью повторяют друг друга на этапе создания контекста.

http://jsflow.org/docs/block-exec-context/  - см пример

Отличия жизненного цикла let и const переменных от var переменных
Рассмотрим жизненный цикл переменных var, для которых нет временной мертвой зоны. Когда выполнение программы достигает области 
видимости, где объявлена переменная var, на этапе создания контекста исполнения для нее выделяется пространство под хранение 
в памяти (другими словами происходит всплытие) и переменная сразу инициализируется значением undefined. Далее, когда выполнение 
программы достигает объявления этой переменной, ей присваивается новое значение, в случае, если никакое значение не указано, 
оно остается равным undefined.
Для переменных let и const жизненный цикл немного отличается. Когда выполнение программы достигает области видимости, где объявлены 
переменные let или const, на этапе создания контекста исполнения для них также выделяется пространство под хранение в памяти 
(то есть они тоже всплывают), но немедленная инициализация переменных не происходит. В спецификации говорится, что к этим 
переменным нельзя получить доступ на чтение или запись пока не выполнилось их Лексическое Связывание - LexicalBinding, это и 
есть та самая временная мертвая зона.
Еще одним отличием var от let или const является то, что одни и те же переменные var можно объявлять несколько раз, а переменные 
let и const могут быть объявлены только один раз.



5. КЛЮЧЕВОЕ СЛОВО this
При создании Лексического Окружения, например если была вызвана функция, формируется соответствующая Запись Окружения. И эта 
Запись Окружения содержит в себе не только информацию о переменных текущей области видимости, но и ключевое слово this, к которому 
можно обратиться напрямую из кода. Значение this динамически устанавливается JavaScript-движком на этапе создания контекста 
выполнения и указывает на объект, связанный с этим контекстом
- Значение this в глобальном контексте.
  Ключевое слово this будет ссылаться на глобальный объект Window
- Значение this в контексте функции.
  Объект, на который будет ссылаться ключевое слово this зависит от того, где и при каких условиях эта функция была вызвана:
     а) Простой вызов функции (из глобального контекста)
        В случае вызова этой функции не в строгом режиме, значением this будет являться глобальный объект Window.
        А в строгом режиме use strict, значением this будет undefined
     б) Вызов функции как метода объекта.
        Если функция вызывается как метод объекта, то ключевое слово this в рамках этой функции будет указывать на сам этот объект, 
        одом которого она была вызвана (this в данном случае является ближайший объект перед точкой)
     в) Явная передача контекста в функцию.
        Первым параметром в них задаётся значение this, а последующими необязательными параметрами - аргументы, с которыми будет 
        вызываться функция. Причем для метода call аргументы передаются списком через запятую fun.call(thisArg[, 
        arg1[, arg2[, ...]]]). А для метода apply они передаются при помощи одного массива fun.apply(thisArg[, argsArray]).
        Так же еще есть метод bind, который тоже позволяет явно передать контекст в функцию, но в отличие от методов call и apply 
        не вызывает сразу функцию, а возвращает её обёртку