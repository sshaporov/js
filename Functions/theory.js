console.log('Functions env - теория')

// Функция – это значение, представляющее «действие»
// Обычные значения, такие как строки или числа представляют собой данные.
// Функции, с другой стороны, можно воспринимать как «действия».
// Мы можем передавать их из переменной в переменную и запускать, когда захотим.


// Стрелочные функции
// https://learn.javascript.ru/arrow-functions
let group = {
    title: "Our Group",
    students: ["John", "Pete", "Alice"],

    showList() {
        this.students.forEach(
            student => alert(this.title + ': ' + student)
        );
    }
};

group.showList();
// Здесь внутри forEach использована стрелочная функция, таким образом this.title в ней будет иметь
// точно такое же значение, как в методе showList: group.title.
// Если бы мы использовали «обычную» функцию, была бы ошибка, тк forEach по умолчанию выполняет функции с this,
// равным undefined, и в итоге мы пытаемся обратиться к undefined.title.
// Это не влияет на стрелочные функции, потому что у них просто нет this.

// Стрелочные функции – это не просто «сокращение», чтобы меньше писать. У них есть ряд других полезных особенностей.
// 1) нет «this»
// 2) Стрелочные функции не могут быть использованы как конструкторы (new)
// Существует тонкая разница между стрелочной функцией => и обычной функцией, вызванной с .bind(this):
// .bind(this) создаёт «связанную версию» функции.
// Стрелка => ничего не привязывает. У функции просто нет this. При получении значения this – оно,
// как обычная переменная, берётся из внешнего лексического окружения.
// 3) У стрелочных функций также нет переменной arguments
// И это все потому, что они предназначены для небольшого кода, который не имеет своего «контекста»,
// выполняясь в текущем. И они отлично справляются с этой задачей!



// Function declaration
// https://learn.javascript.ru/closure#function-declaration
function sayHi() {
    alert( "Hi" );
}
// Function Declaration:
//     В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
//     Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.
//     Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.

// Function expression
let sayByi = function() {
    alert( "Byi" );
};
// Мы можем скопировать функцию в другую переменную



// Function Expression в сравнении с Function Declaration
// 1) Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
// 2) Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции.
// В данном случае функция создаётся в правой части «выражения присваивания» =
// 3) Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).
// 4) Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
// 5) В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока.
// Но не снаружи него.


