
***** https://habr.com/ru/company/ruvds/blog/444348/

1. Разлия классовых компонент от функциональных заключается в модели их использования
2. Нужно использовать компонент класса вместо компонента функции, когда ваш компонент должен хранить и манипулировать
своим собственным внутренним состоянием или когда вам нужен доступ к нескольким методам жизненного цикла, таким как
componentDidMount и т.д., для выполнения сетевых операций, манипулировать DOM, взаимодействовать со сторонними
библиотеками и т.д.
3. При создании инстанса класса, методы (обработчики) описанные в классе создаются 1 раз и в методе render() мы
используем ссылку наэтот метод. Т.е. при каждом рендере мы обращаемся к одной и той же ссылке, не пересоздавая ее
при вызове метода render()
4. В функциональной компоненте при создании обработчика, мы описываем его внутри рендера, тк все тело функции (компоненты)
и есть рендер (другого метода и не существует если мы хотим использовать пропсы), поэтому мы каждый раз создаем функцию
при каждом рендере
5. Создание инстанса класса настолько дорогостоящая операция что создавать функцию на каждый рендер на порядок дешевле

Цель наличия this в классе кроется в возможности this изменяться. Сама библиотека React периодически выполняет мутации
this, что позволяет работать со свежими версиями метода render и методов жизненного цикла компонента
В результате, если наш компонент выполняет повторный рендеринг во время выполнения запроса, this.props изменится.
После этого метод showMessage прочтёт значение user из «слишком новой» сущности props.
Это позволяет сделать интересное наблюдение, касающееся пользовательских интерфейсов. Если сказать, что пользовательский
интерфейс, концептуально, представляет собой функцию текущего состояния приложения, то обработчики событий являются
частью результатов рендеринга — так же, как и видимые результаты рендеринга. Наши обработчики событий «принадлежат»
конкретной операции рендеринга вместе с конкретными свойствами и состоянием.
Однако планирование таймаута, коллбэк которого читает this.props, нарушает эту связь. Коллбэк showMessage не «привязан»
ни к какой конкретной операции рендеринга, в результате он «теряет» правильные свойства. Чтение данных из this разрывает
эту связь.


Свойства экземпляра
1. props
this.props содержит свойства, которые были определены тем, кто вызывает этот компонент. Подробнее об этом можно узнать
в разделе Компоненты и пропсы
Существует специальный проп this.props.children, который обычно определяется дочерними тегами в JSX-выражении, а не в
самом теге.

2. state
Состояние содержит данные, специфичные для этого компонента. Они могут измениться со временем. Состояние определяется
пользователем и должно быть простым объектом JavaScript.
Вам не нужно вставлять в состояние значение, если оно не используется для рендера или потока данных (например,
идентификатор таймера). Такие значения можно определить как поля экземпляра компонента.
Дополнительную информацию можно найти в разделе Состояние и жизненный цикл.
Никогда не мутируйте this.state напрямую, так как более поздний вызов setState() может перезаписать эту мутацию.
Относитесь к this.state как к иммутабельному объекту.

