Жизненный цикл компонента:

1. Монтирование:
При создании экземпляра компонента и его вставке в DOM, следующие методы вызываются в установленном порядке:
- constructor()
- static getDerivedStateFromProps()
- render()
- componentDidMount()

2. Обновление
Обновление происходит при изменении пропсов или состояния. Следующие методы вызываются в установленном порядке при
повторном рендере компонента:
- static getDerivedStateFromProps()
- shouldComponentUpdate()
- render()
- getSnapshotBeforeUpdate()
- componentDidUpdate()

3. Размонтирование:
Этот метод вызывается при удалении компонента из DOM:
- componentWillUnmount()

4. Обработка ошибок:
Следующие методы вызываются, если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе
любого дочернего компонента.
- static getDerivedStateFromError()
- componentDidCatch()



5. Распространённые методы жизненного цикла

5.1 render()
Единственный обязательный метод в классовом компоненте.
При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов:
Элемент React. Обычно создаётся с помощью JSX. Указывает React, что рендерить: DOM-узел или пользовательский компонент.
Например, <div /> или <MyComponent />.
Массивы и фрагменты. Возвращает несколько элементов из render(). Подробнее про фрагменты.
Порталы. Рендерит несколько дочерних элементов в другое поддерево DOM. Подробнее про порталы.
Строки и числа. Рендерит текстовые DOM-узлы.
Booleans или null. Ничего не рендерит. (Обычно необходим для поддержки паттерна return test && <Child />, где test —
логическое значение.)
Функция render() должна быть чистой. Это означает, что она не изменяет состояние компонента, всегда возвращает один и
тот же результат, не взаимодействует напрямую с браузером.

5.2 constructor()
Вы можете не использовать конструктор в React-компоненте, если вы не определяете состояние или не привязываете методы.
Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо
вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
Конструкторы в React обычно используют для двух целей:
Инициализация внутреннего состояния через присвоение объекта this.state.
Привязка обработчиков событий к экземпляру.
Вы не должны вызывать setState() в constructor(). Если вам нужно внутреннее состояние, присвойте начальное состояние
this.state прямо в конструкторе.
Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать
this.setState().
Не используйте побочные эффекты или подписки в конструкторе. Вместо этого используйте componentDidMount().

5.3 componentDidMount()
Вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны
происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
Вы можете сразу вызвать setState() в componentDidMount(). Это вызовет дополнительный рендер перед тем, как браузер
обновит экран. Гарантируется, что пользователь не увидит промежуточное состояние, даже если render() будет вызываться
дважды. Используйте этот подход с осторожностью, он может вызвать проблемы с производительностью. В большинстве случаев
начальное состояние лучше объявить в constructor(). Однако, это может быть необходимо для случаев, когда нужно измерить
размер или положение DOM-узла, на основе которого происходит рендер. Например, для модальных окон или всплывающих подсказок.

5.4 componentDidUpdate()
componentDidUpdate(prevProps, prevState, snapshot)
componentDidUpdate() вызывается сразу после обновления. Не вызывается при первом рендере.
Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые
выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос
может и не требоваться.
Пример(не забудьте сравнить пропсы):
componentDidUpdate(prevProps) {
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
В componentDidUpdate() можно вызывать setState(), однако его необходимо обернуть в условие, как в примере выше, чтобы
не возник бесконечный цикл. Вызов setState() влечет за собой дополнительный рендер, который незаметен для пользователя,
 но может повлиять на производительность компонента. Вместо «отражения» пропсов в состоянии рекомендуется использовать
 пропсы напрямую. Подробнее о том, почему копирование пропсов в состояние вызывает баги.
В тех редких случаях когда реализован метод жизненного цикла getSnapshotBeforeUpdate(), его результат передаётся
componentDidUpdate() в качестве третьего параметра snapshot.

5.5 componentWillUnmount()
Вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс:
отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
Не используйте setState() в componentWillUnmount(), так как компонент никогда не рендерится повторно. После того, как
экземпляр компонента будет размонтирован, он никогда не будет примонтирован снова.


6. Редко используемые методы жизненного цикла

6.1 shouldComponentUpdate()
shouldComponentUpdate(nextProps, nextState)
Используйте shouldComponentUpdate(), чтобы указать необходимость следующего рендера на основе изменений состояния и
пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. В большинстве случаев вы должны
полагаться на это поведение.
shouldComponentUpdate() вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию
равно true. Этот метод не вызывается при первом рендере или когда используется forceUpdate().


6.2 static getDerivedStateFromProps()
getDerivedStateFromProps вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и
при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах. Например, это подойдёт для
реализации компонента <Transition>, который сравнивает свои предыдущие и следующие дочерние компоненты, чтобы решить,
какой из них нужно анимировать.
Обратите внимание, что этот метод запускается при каждом рендере, независимо от причины. Это отличается от метода
UNSAFE_componentWillReceiveProps, который запускается только при повторном рендере родительского компонента, а не в
результате вызова setState.

6.3 getSnapshotBeforeUpdate()
getSnapshotBeforeUpdate(prevProps, prevState)
getSnapshotBeforeUpdate() вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он
позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным
изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
Это применяется редко, но может быть полезно в таких интерфейсах, как цепочка сообщений в чатах, в которых позиция прокрутки
обрабатывается особым образом.

6.4 Предохранители
Это React-компоненты, которые перехватывают JavaScript-ошибки в любом месте их дочернего дерева компонентов.
Затем логируют эти ошибки и отображают запасной интерфейс вместо «поломанного» дерева компонентов. Предохранители
отлавливают ошибки при рендере, в методах жизненного цикла и в конструкторах всего дерева под ними.
Классовый компонент становится предохранителем, если в нём используются методы жизненного цикла
static getDerivedStateFromError() и (или) componentDidCatch(). Обновление состояния в этом методе жизненного цикла
позволяет перехватить необработанную JavaScript-ошибку в дереве ниже и отобразить запасной интерфейс.
Используйте предохранители только для обработки неожиданных исключений, не используйте их для управления потоком
исполнения в вашем приложении.

6.4 static getDerivedStateFromError()
static getDerivedStateFromError(error)
Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве
параметра и возвращает значение для обновления состояния.

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновите состояние так, чтобы следующий рендер показал запасной интерфейс.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // Здесь можно рендерить запасной интерфейс
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}

Примечание:
getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их
можно использовать в componentDidCatch().

6.5 componentDidCatch()
componentDidCatch(error, info)
Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра:
error — перехваченная ошибка
info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка.
componentDidCatch() вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно
использовать для логирования ошибок.






